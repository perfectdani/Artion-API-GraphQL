package auth

import (
	"artion-api-graphql/internal/config"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"strings"
)

// challengePrefix is template of message to be signed using Metamask.
const challengePrefix = "Click \"Sign\" to sign in into Artion.\n\nNonce:"
const challengePrefixLen = len(challengePrefix)

var instance *Authenticator

// GetAuthenticator provides access to the singleton instance of the Authenticator.
func GetAuthenticator() *Authenticator {
	return instance
}

// SetConfig sets the configuration to be used and initialize the singleton instance.
func SetConfig(c *config.Config) {
	instance = &Authenticator{
		bearerSecret: hexutil.MustDecode(c.Auth.BearerSecret),
		nonceSecret:  hexutil.MustDecode(c.Auth.NonceSecret),
	}
}

// Authenticator is object responsible for user authentication.
type Authenticator struct {
	bearerSecret []byte
	nonceSecret  []byte
}

// GenerateChallenge provides message to be signed using Metamask.
func (a Authenticator) GenerateChallenge() (string, error) {
	nonce, err := generateNonce(a.nonceSecret)
	if err != nil {
		return "", err
	}
	return challengePrefix + nonce, nil
}

// GenerateBearer verifies signed challenge and issues bearer token against it.
func (a Authenticator) GenerateBearer(challenge string, address common.Address, signatureHex string) (string, error) {
	err := a.verifySignedChallenge(challenge, address, signatureHex)
	if err != nil {
		return "", err
	}

	return generateBearer(&address, a.bearerSecret)
}

// VerifyBearer verifies issued bearer token and returns proved user address.
func (a Authenticator) VerifyBearer(bearer string) (*common.Address, error) {
	return verifyBearer(bearer, a.bearerSecret)
}

// verifySignedChallenge verifies user response to authentication challenge
func (a Authenticator) verifySignedChallenge(challenge string, address common.Address, signatureHex string) error {
	err := a.verifyChallengeContent(challenge)
	if err != nil {
		return fmt.Errorf("nonce verification failed; %s", err)
	}
	signature, err := hexutil.Decode(signatureHex)
	if err != nil {
		return fmt.Errorf("signature hex decoding failed; %s", err)
	}
	ok, err := verifySignature(challenge, address, signature)
	if err != nil || !ok {
		return fmt.Errorf("signature verification failed; %s", err)
	}
	return nil
}

// verifyChallengeContent verifies nonce in the login challenge - checks it was generated by trustworthy server.
func (a Authenticator) verifyChallengeContent(challenge string) error {
	if ! strings.HasPrefix(challenge, challengePrefix) {
		return fmt.Errorf("signed challenge has unexpected format")
	}
	nonce := challenge[challengePrefixLen:]
	return verifyNonce(nonce, a.nonceSecret)
}
