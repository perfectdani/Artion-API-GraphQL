package auth

import (
	"artion-api-graphql/internal/config"
	"fmt"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"strings"
)

// challengeTemplate is template of message to be signed using Metamask.
const challengeTemplate = "Click \"Sign\" to sign in into Artion.\n\nNonce:%s"

var instance *Authenticator

// GetAuthenticator provides access to the singleton instance of the Authenticator.
func GetAuthenticator() *Authenticator {
	return instance
}

// SetConfig sets the configuration to be used and initialize the singleton instance.
func SetConfig(c *config.Config) {
	instance = &Authenticator{
		bearerSecret: hexutil.MustDecode(c.Auth.BearerSecret),
		nonceSecret:  hexutil.MustDecode(c.Auth.NonceSecret),
	}
}

// Authenticator is object responsible for user authentication.
type Authenticator struct {
	bearerSecret []byte
	nonceSecret  []byte
}

// GenerateChallenge provides message to be signed using Metamask.
func (a Authenticator) GenerateChallenge() (string, error) {
	nonce, err := generateNonce(a.nonceSecret)
	if err != nil {
		return "", err
	}
	return fmt.Sprintf(challengeTemplate, nonce), nil
}

// GenerateBearer verifies signed challenge and issues bearer token against it.
func (a Authenticator) GenerateBearer(challenge string, address common.Address, signatureHex string) (string, error) {
	err := a.verifySignedChallenge(challenge, address, signatureHex)
	if err != nil {
		return "", err
	}

	return generateBearer(&address, a.bearerSecret)
}

// VerifyBearer verifies issued bearer token and returns proved user address.
func (a Authenticator) VerifyBearer(bearer string) (*common.Address, error) {
	return verifyBearer(bearer, a.bearerSecret)
}

// verifySignedChallenge verifies user response to authentication challenge
func (a Authenticator) verifySignedChallenge(challenge string, address common.Address, signatureHex string) error {
	err := a.verifyNonceInChallenge(challenge)
	if err != nil {
		return fmt.Errorf("nonce verification failed; %s", err)
	}
	signature, err := hexutil.Decode(signatureHex)
	if err != nil {
		return fmt.Errorf("signature hex decoding failed; %s", err)
	}
	ok, err := verifySignature(challenge, address, signature)
	if err != nil || !ok {
		return fmt.Errorf("signature verification failed; %s", err)
	}
	return nil
}

// verifyNonceInChallenge verifies nonce in the login challenge - checks it was generated by trustworthy server.
func (a Authenticator) verifyNonceInChallenge(challenge string) error {
	// needs to be in sync with challengeTemplate
	index := strings.LastIndex(challenge, "Nonce:") + 6
	if index == -1 || len(challenge) <= index {
		return fmt.Errorf("no nonce found in challenge [%s]", challenge)
	}
	nonce := challenge[index:]
	return verifyNonce(nonce, a.nonceSecret)
}
